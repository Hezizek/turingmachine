@@ FILE: main.cpp
#include "CLIHandler.h"

int main(int argc, char* argv[]) {
    return CLIHandler::Main(argc, argv);
}
@@ FILE: CLIHandler.cpp
#include "CLIHandler.h"
#include "ErrorHandler.h"
#include "TMParser.h"
#include "InputValidator.h"
#include "MachineSimulator.h"
#include "VerboseTracer.h"
#include "ResultPrinter.h"
#include <iostream>
#include <vector>
#include <string>

int CLIHandler::Main(int argc, char* argv[]) {
    bool hasHelp = false;
    if (argc == 1) {
        hasHelp = true;
    } else {
        for (int i = 1; i < argc; ++i) {
            std::string a = argv[i];
            if (a == "-h" || a == "--help") {
                hasHelp = true;
                break;
            }
        }
    }
    if (hasHelp) {
        CLIHandler::PrintHelp();
        return 0;
    }

    bool verboseMode = false;
    std::vector<std::string> filteredArgs;
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "-v" || arg == "--verbose") {
            verboseMode = true;
        } else {
            filteredArgs.push_back(arg);
        }
    }

    if (filteredArgs.size() != 2) {
        ErrorHandler::ReportUsageError();
        return 1;
    }

    std::string tmFilePath = filteredArgs[0];
    std::string inputString = filteredArgs[1];

    TuringMachine turingMachine;
    try {
        turingMachine = TMParser::Parse(tmFilePath);
    } catch (const std::exception& e) {
        ErrorHandler::Report(e.what());
        return 1;
    }

    bool isValid = InputValidator::Validate(inputString, turingMachine.inputAlphabet);
    if (!isValid) {
        if (verboseMode) {
            ErrorHandler::ReportVerboseIllegalInput(inputString, turingMachine.inputAlphabet);
        } else {
            ErrorHandler::ReportIllegalInput();
        }
        return 1;
    }

    if (verboseMode) {
        VerboseTracer::SimulateAndTrace(turingMachine, inputString);
    } else {
        MachineConfiguration finalConfig = MachineSimulator::Simulate(turingMachine, inputString);
        ResultPrinter::PrintFinalResult(finalConfig);
    }

    return 0;
}

void CLIHandler::PrintHelp() {
    std::cout << "usage: turing [-v|--verbose] [-h|--help] <tm> <input>" << std::endl;
}
@@ FILE: InputValidator.cpp
#include "InputValidator.h"

bool InputValidator::Validate(const std::string& inputString, const std::set<char>& inputAlphabet) {
    for (size_t i = 0; i < inputString.size(); ++i) {
        char symbol = inputString[i];
        if (inputAlphabet.find(symbol) == inputAlphabet.end()) {
            return false;
        }
    }
    return true;
}
@@ FILE: MachineSimulator.cpp
#include "MachineSimulator.h"

MachineConfiguration MachineSimulator::Simulate(const TuringMachine& tm, const std::string& input) {
    MachineConfiguration config = MachineSimulator::initializeConfiguration(tm, input);
    int step = 0;
    while (true) {
        bool matched = false;
        for (const auto& transition : tm.transitions) {
            if (transition.oldState != config.currentState) {
                continue;
            }
            if (MachineSimulator::matchSymbols(config, transition.oldSymbols, tm.blankSymbol)) {
                MachineSimulator::applyTransition(config, transition, tm.blankSymbol);
                matched = true;
                break;
            }
        }
        if (!matched) {
            break;
        }
        step = step + 1;
    }
    return config;
}

MachineConfiguration MachineSimulator::initializeConfiguration(const TuringMachine& tm, const std::string& input) {
    std::vector<Tape> tapes;
    for (int i = 0; i < tm.tapeCount; ++i) {
        Tape tape;
        tape.cells.clear();
        if (i == 0) {
            for (int j = 0; j < static_cast<int>(input.size()); ++j) {
                tape.cells[j] = input[static_cast<size_t>(j)];
            }
        }
        tape.headPosition = 0;
        tapes.push_back(tape);
    }
    MachineConfiguration config;
    config.currentState = tm.initialState;
    config.tapes = tapes;
    return config;
}

bool MachineSimulator::matchSymbols(const MachineConfiguration& config, const std::vector<char>& oldSymbols, char blankSymbol) {
    for (size_t i = 0; i < oldSymbols.size(); ++i) {
        int headPos = config.tapes[i].headPosition;
        char symbol = blankSymbol;
        auto it = config.tapes[i].cells.find(headPos);
        if (it != config.tapes[i].cells.end()) {
            symbol = it->second;
        }
        char expected = oldSymbols[i];
        if (expected == '*') {
            if (symbol == blankSymbol) {
                return false;
            }
        } else {
            if (symbol != expected) {
                return false;
            }
        }
    }
    return true;
}

void MachineSimulator::applyTransition(MachineConfiguration& config, const Transition& t, char /*blank*/) {
    for (size_t i = 0; i < config.tapes.size(); ++i) {
        Tape& tape = config.tapes[i];
        int headPos = tape.headPosition;
        char writeSymbol = t.newSymbols[i];
        if (writeSymbol != '*') {
            tape.cells[headPos] = writeSymbol;
        }
        Direction direction = t.directions[i];
        if (direction == Direction::LEFT) {
            tape.headPosition = headPos - 1;
        } else if (direction == Direction::RIGHT) {
            tape.headPosition = headPos + 1;
        } else {
            tape.headPosition = headPos;
        }
    }
    config.currentState = t.newState;
}
@@ FILE: TMParser.cpp
#include "TMParser.h"
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <cctype>
#include <algorithm>

namespace {
    inline std::string Trim(const std::string& s) {
        size_t start = 0;
        while (start < s.size() && std::isspace(static_cast<unsigned char>(s[start]))) ++start;
        size_t end = s.size();
        while (end > start && std::isspace(static_cast<unsigned char>(s[end - 1]))) --end;
        return s.substr(start, end - start);
    }

    inline bool startsWith(const std::string& s, const std::string& prefix) {
        return s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());
    }

    inline bool endsWith(const std::string& s, const std::string& suffix) {
        return s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
    }

    inline std::vector<std::string> SplitOnce(const std::string& s, const std::string& delim) {
        std::vector<std::string> parts;
        size_t pos = s.find(delim);
        if (pos == std::string::npos) {
            parts.push_back(s);
        } else {
            parts.push_back(s.substr(0, pos));
            parts.push_back(s.substr(pos + delim.size()));
        }
        return parts;
    }

    inline std::vector<std::string> SplitByComma(const std::string& s) {
        std::vector<std::string> items;
        std::string current;
        std::istringstream iss(s);
        while (std::getline(iss, current, ',')) {
            items.push_back(current);
        }
        return items;
    }

    inline bool isInteger(const std::string& s) {
        if (s.empty()) return false;
        for (char c : s) {
            if (!std::isdigit(static_cast<unsigned char>(c))) return false;
        }
        return true;
    }

    inline std::set<char> ToCharSet(const std::set<std::string>& strs) {
        std::set<char> out;
        for (const auto& it : strs) {
            if (it.size() == 1) {
                out.insert(it[0]);
            }
        }
        return out;
    }
}

TuringMachine TMParser::Parse(const std::string& filePath) {
    std::ifstream fin(filePath.c_str());
    if (!fin) {
        throw std::runtime_error("syntax error");
    }
    TuringMachine tm;
    tm.transitions.clear();
    std::string line;
    while (std::getline(fin, line)) {
        std::string trimmed = Trim(line);
        if (trimmed.empty() || startsWith(trimmed, ";")) {
            continue;
        }
        if (startsWith(trimmed, "#Q")) {
            tm.states = TMParser::parseSet(trimmed, "state");
        } else if (startsWith(trimmed, "#S")) {
            std::set<std::string> s = TMParser::parseSet(trimmed, "inputalphabet");
            tm.inputAlphabet = ToCharSet(s);
        } else if (startsWith(trimmed, "#G")) {
            std::set<std::string> s = TMParser::parseSet(trimmed, "tapealphabet");
            tm.tapeAlphabet = ToCharSet(s);
            for (char symbol : tm.inputAlphabet) {
                if (tm.tapeAlphabet.find(symbol) == tm.tapeAlphabet.end()) {
                    throw std::runtime_error("syntax error");
                }
            }
        } else if (startsWith(trimmed, "#q0")) {
            std::string s = TMParser::parseSingle(trimmed);
            tm.initialState = s;
            if (tm.states.find(tm.initialState) == tm.states.end()) {
                throw std::runtime_error("syntax error");
            }
        } else if (startsWith(trimmed, "#B")) {
            std::string s = TMParser::parseSingle(trimmed);
            if (s.size() != 1) {
                throw std::runtime_error("syntax error");
            }
            char b = s[0];
            if (tm.tapeAlphabet.find(b) == tm.tapeAlphabet.end() || b != '_') {
                throw std::runtime_error("syntax error");
            }
            tm.blankSymbol = b;
        } else if (startsWith(trimmed, "#F")) {
            tm.finalStates = TMParser::parseSet(trimmed, "state");
            for (const auto& state : tm.finalStates) {
                if (tm.states.find(state) == tm.states.end()) {
                    throw std::runtime_error("syntax error");
                }
            }
        } else if (startsWith(trimmed, "#N")) {
            tm.tapeCount = TMParser::parseInt(trimmed);
        } else {
            Transition transition = TMParser::parseTransition(trimmed, tm.tapeCount, tm.states, tm.tapeAlphabet);
            tm.transitions.push_back(transition);
        }
    }
    return tm;
}

std::set<std::string> TMParser::parseSet(const std::string& line, const std::string& type) {
    auto parts = SplitOnce(line, " = ");
    if (parts.size() != 2) {
        throw std::runtime_error("syntax error");
    }
    std::string body = Trim(parts[1]);
    if (!(startsWith(body, "{") && endsWith(body, "}"))) {
        throw std::runtime_error("syntax error");
    }
    std::string content = body.substr(1, body.size() - 2);
    auto rawItems = SplitByComma(content);
    std::set<std::string> items;
    for (auto item : rawItems) {
        item = Trim(item);
        if (item.empty()) {
            throw std::runtime_error("syntax error");
        }
        if (type == "state") {
            for (char c : item) {
                if (!(std::isalnum(static_cast<unsigned char>(c)) || c == '_')) {
                    throw std::runtime_error("syntax error");
                }
            }
        } else if (type == "inputalphabet") {
            if (item.size() != 1) {
                throw std::runtime_error("syntax error");
            }
            char c = item[0];
            if (c == ' ' || c == ',' || c == ';' || c == '{' || c == '}' || c == '*' || c == '_') {
                throw std::runtime_error("syntax error");
            }
        } else if (type == "tapealphabet") {
            if (item.size() != 1) {
                throw std::runtime_error("syntax error");
            }
            char c = item[0];
            if (c == ' ' || c == ',' || c == ';' || c == '{' || c == '}' || c == '*') {
                throw std::runtime_error("syntax error");
            }
        }
        items.insert(item);
    }
    return items;
}

std::string TMParser::parseSingle(const std::string& line) {
    auto parts = SplitOnce(line, " = ");
    if (parts.size() != 2) {
        throw std::runtime_error("syntax error");
    }
    return Trim(parts[1]);
}

int TMParser::parseInt(const std::string& line) {
    std::string value = TMParser::parseSingle(line);
    if (!isInteger(value)) {
        throw std::runtime_error("syntax error");
    }
    return std::stoi(value);
}

Transition TMParser::parseTransition(
    const std::string& line,
    int tapeCount,
    const std::set<std::string>& states,
    const std::set<char>& symbols
) {
    std::istringstream iss(line);
    std::string oldState, readSymbols, writeSymbols, directions, newState;
    if (!(iss >> oldState >> readSymbols >> writeSymbols >> directions >> newState)) {
        throw std::runtime_error("syntax error");
    }
    // Ensure no extra tokens
    std::string extra;
    if (iss >> extra) {
        throw std::runtime_error("syntax error");
    }

    if (static_cast<int>(readSymbols.size()) != tapeCount ||
        static_cast<int>(writeSymbols.size()) != tapeCount ||
        static_cast<int>(directions.size()) != tapeCount) {
        throw std::runtime_error("syntax error");
    }
    if (states.find(oldState) == states.end() || states.find(newState) == states.end()) {
        throw std::runtime_error("syntax error");
    }

    for (int i = 0; i < tapeCount; ++i) {
        char r = readSymbols[static_cast<size_t>(i)];
        char w = writeSymbols[static_cast<size_t>(i)];
        char d = directions[static_cast<size_t>(i)];
        if (r != '*' && symbols.find(r) == symbols.end()) {
            throw std::runtime_error("syntax error");
        }
        if (w != '*' && symbols.find(w) == symbols.end()) {
            throw std::runtime_error("syntax error");
        }
        if (!(d == 'l' || d == 'r' || d == '*')) {
            throw std::runtime_error("syntax error");
        }
    }

    Transition t;
    t.oldState = oldState;
    t.oldSymbols.assign(readSymbols.begin(), readSymbols.end());
    t.newSymbols.assign(writeSymbols.begin(), writeSymbols.end());
    t.directions.clear();
    t.directions.reserve(static_cast<size_t>(tapeCount));
    for (char d : directions) {
        if (d == 'l') t.directions.push_back(Direction::LEFT);
        else if (d == 'r') t.directions.push_back(Direction::RIGHT);
        else t.directions.push_back(Direction::STAY);
    }
    t.newState = newState;
    return t;
}
@@ FILE: VerboseTracer.cpp
#include "VerboseTracer.h"
#include "ResultPrinter.h"
#include "MachineSimulator.h"
#include <iostream>

void VerboseTracer::SimulateAndTrace(const TuringMachine& tm, const std::string& input) {
    ResultPrinter::PrintVerboseStart(input);
    MachineConfiguration config = MachineSimulator::initializeConfiguration(tm, input);
    int step = 0;
    while (true) {
        ResultPrinter::PrintVerboseStep(step, config);
        bool matched = false;
        for (const auto& transition : tm.transitions) {
            if (transition.oldState != config.currentState) {
                continue;
            }
            if (MachineSimulator::matchSymbols(config, transition.oldSymbols, tm.blankSymbol)) {
                MachineSimulator::applyTransition(config, transition, tm.blankSymbol);
                matched = true;
                break;
            }
        }
        if (!matched) {
            break;
        }
        step = step + 1;
    }
    ResultPrinter::PrintVerboseResult(config);
}
@@ FILE: ResultPrinter.cpp
#include "ResultPrinter.h"
#include <iostream>
#include <set>
#include <algorithm>
#include <iomanip>
#include <sstream>
#include <vector>

void ResultPrinter::PrintFinalResult(const MachineConfiguration& config) {
    const Tape& tape = config.tapes[0];
    std::vector<int> indices;
    indices.reserve(tape.cells.size());
    for (const auto& kv : tape.cells) {
        indices.push_back(kv.first);
    }
    std::sort(indices.begin(), indices.end());
    if (indices.empty()) {
        std::cout << "" << std::endl;
        return;
    }
    int left = indices.front();
    int right = indices.back();
    std::string output;
    for (int i = left; i <= right; ++i) {
        auto it = tape.cells.find(i);
        char symbol = (it != tape.cells.end()) ? it->second : '_';
        output.push_back(symbol);
    }
    std::cout << output << std::endl;
}

void ResultPrinter::PrintVerboseStart(const std::string& inputString) {
    std::cout << "Input: " << inputString << std::endl;
    std::cout << "==================== RUN ====================" << std::endl;
}

void ResultPrinter::PrintVerboseStep(int step, const MachineConfiguration& config) {
    std::cout << "Step   : " << step << std::endl;
    std::cout << "State  : " << config.currentState << std::endl;
    for (size_t i = 0; i < config.tapes.size(); ++i) {
        const Tape& tape = config.tapes[i];
        int head = tape.headPosition;
        std::vector<int> indices;
        indices.reserve(tape.cells.size() + 1);
        for (const auto& kv : tape.cells) {
            indices.push_back(kv.first);
        }
        indices.push_back(head);
        std::sort(indices.begin(), indices.end());
        indices.erase(std::unique(indices.begin(), indices.end()), indices.end());
        int left = indices.front();
        int right = indices.back();

        std::ostringstream indexLine;
        std::ostringstream symbolLine;
        std::ostringstream headLine;

        indexLine << "Index" << i << " :";
        symbolLine << "Tape" << i << "  :";
        headLine << "Head" << i << "  :";

        for (int j = left; j <= right; ++j) {
            int aj = j < 0 ? -j : j;
            std::string indexStr = std::to_string(aj);
            char symbol = '_';
            auto it = tape.cells.find(j);
            if (it != tape.cells.end()) symbol = it->second;

            bool isHead = (j == head);
            std::string pad(indexStr.size(), ' ');

            indexLine << " " << indexStr;
            symbolLine << pad << symbol;
            if (isHead) {
                headLine << pad << "^";
            } else {
                headLine << pad << " ";
            }
        }

        std::cout << indexLine.str() << std::endl;
        std::cout << symbolLine.str() << std::endl;
        std::cout << headLine.str() << std::endl;
    }
    std::cout << "---------------------------------------------" << std::endl;
}

void ResultPrinter::PrintVerboseResult(const MachineConfiguration& config) {
    const Tape& tape = config.tapes[0];
    std::vector<int> indices;
    indices.reserve(tape.cells.size());
    for (const auto& kv : tape.cells) {
        indices.push_back(kv.first);
    }
    std::sort(indices.begin(), indices.end());
    if (indices.empty()) {
        std::cout << "Result: " << std::endl;
    } else {
        int left = indices.front();
        int right = indices.back();
        std::string output;
        for (int i = left; i <= right; ++i) {
            auto it = tape.cells.find(i);
            char symbol = (it != tape.cells.end()) ? it->second : '_';
            output.push_back(symbol);
        }
        std::cout << "Result: " << output << std::endl;
    }
    std::cout << "==================== END ====================" << std::endl;
}
@@ FILE: ErrorHandler.cpp
#include "ErrorHandler.h"
#include <iostream>

void ErrorHandler::Report(const std::string& errorMessage) {
    std::cerr << errorMessage << std::endl;
}

void ErrorHandler::ReportUsageError() {
    std::cerr << "usage: turing [-v|--verbose] [-h|--help] <tm> <input>" << std::endl;
}

void ErrorHandler::ReportIllegalInput() {
    std::cerr << "illegal input" << std::endl;
}

void ErrorHandler::ReportVerboseIllegalInput(const std::string& inputString, const std::set<char>& inputAlphabet) {
    std::cout << "Input: " << inputString << std::endl;
    std::cout << "==================== ERR ====================" << std::endl;
    for (size_t i = 0; i < inputString.size(); ++i) {
        if (inputAlphabet.find(inputString[i]) == inputAlphabet.end()) {
            std::cout << "error: '" << inputString[i] << "' was not declared in the set of input symbols" << std::endl;
            std::cout << "Input: " << inputString << std::endl;
            std::string marker(i, ' ');
            marker.push_back('^');
            std::cout << "       " << marker << std::endl;
            break;
        }
    }
    std::cout << "==================== END ====================" << std::endl;
}


The total prompt token usage is:  4984
The total completion token usage is:  11735

